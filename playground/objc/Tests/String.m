//
//  String
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "String.h"

@implementation NSMutableString ( String )

+ (NSMutableString*) fromCharCode:(int)code{
	return [NSString stringWithFormat:@"%C", code];
}
// Please provide a getterBody for the property: length

- (NSMutableString*) toUpperCase{
	return [self uppercaseString];
}
- (NSMutableString*) toLowerCase{
	return [self lowercaseString];
}
- (NSMutableString*) charAt:(int)index{
	return nil;
}
- (int) charCodeAt:(int)index{
	return [self characterAtIndex:index];
}
- (int) indexOf:(NSMutableString*)str startIndex:(int)startIndex{
	// Optional arguments
	if (!startIndex) startIndex = nil;
	
	startIndex = ( (startIndex == nil) ? 0 : startIndex);
	NSRange range = [self rangeOfString:str options:NSLiteralSearch range:NSMakeRange(startIndex,self.length-startIndex)];
	if ( range.location != NSNotFound ) {
		return range.location;
	};
	return -1;
}
- (int) lastIndexOf:(NSMutableString*)str startIndex:(int)startIndex{
	// Optional arguments
	if (!startIndex) startIndex = nil;
	
	startIndex = ( (startIndex == nil) ? 0 : startIndex);
	NSRange range = [self rangeOfString:str options:NSBackwardsSearch range:NSMakeRange(startIndex,self.length-startIndex)];
	if ( range.location != NSNotFound ) {
		return range.location;
	};
	return -1;
}
- (NSMutableArray*) split:(NSMutableString*)delimiter{
	return [self componentsSeparatedByString:delimiter];
}
- (NSMutableString*) substr:(int)pos len:(int)len{
	// Optional arguments
	if (!len) len = nil;
	
	if (len == 0) return [@"" mutableCopy];
	int sl = self.length;
	if (len == nil) len = sl;
	if (pos == nil) pos = 0;
	if (pos != 0 && len < 0) return [@"" mutableCopy];
	if (pos < 0) {
		pos = sl + pos;
		if (pos < 0) pos = 0;
	}
	else if (len < 0) len = sl + len - pos;
	if (pos + len > sl) len = sl - pos;
	if (pos < 0 || len <= 0) return [@"" mutableCopy];
	return [self substringFromIndex:pos];
	return [self substringWithRange:NSMakeRange(pos,len)];
}
- (NSMutableString*) substring:(int)startIndex endIndex:(int)endIndex{
	// Optional arguments
	if (!endIndex) endIndex = nil;
	
	if (endIndex == nil) endIndex = self.length;
	else if (endIndex < 0) endIndex = 0;
	else if (endIndex > self.length) endIndex = self.length;
	if (startIndex < 0) startIndex = 0;
	else if (startIndex > self.length) startIndex = self.length;
	if (startIndex > endIndex) {
		int tmp = startIndex;
		startIndex = endIndex;
		endIndex = tmp;
	}
	return [self substr:startIndex len:endIndex - startIndex];
}
- (NSMutableString*) toString{
	return [self description];
}
- (id) init:(NSMutableString*)string{
	self = [super init];
	return self;
}

@end
