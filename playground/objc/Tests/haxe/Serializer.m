//
//  Serializer
//  Tests
//
//  Source generated by Haxe Objective-C target
//

#import "../haxe/Serializer.h"

@implementation Serializer

static BOOL USE_CACHE;
+ (BOOL) USE_CACHE {
	if (USE_CACHE == nil) USE_CACHE = NO;
	return USE_CACHE;
}
+ (void) setUSE_CACHE:(BOOL)hx_val {
	USE_CACHE = hx_val;
}
static BOOL USE_ENUM_INDEX;
+ (BOOL) USE_ENUM_INDEX {
	if (USE_ENUM_INDEX == nil) USE_ENUM_INDEX = NO;
	return USE_ENUM_INDEX;
}
+ (void) setUSE_ENUM_INDEX:(BOOL)hx_val {
	USE_ENUM_INDEX = hx_val;
}
static NSMutableString* BASE64;
+ (NSMutableString*) BASE64 {
	if (BASE64 == nil) BASE64 = [@"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:" mutableCopy];
	return BASE64;
}
+ (void) setBASE64:(NSMutableString*)hx_val {
	BASE64 = hx_val;
}
+ (NSMutableString*) run:(id)v{
	
	
	Serializer *s = [[Serializer alloc] init];
	[s serialize:v];
	return [s toString];
}
@synthesize buf;
@synthesize cache;
@synthesize shash;
@synthesize scount;
@synthesize useCache;
@synthesize useEnumIndex;
- (NSMutableString*) toString{
	
	return self.buf.b;
}
- (void) serializeString:(NSMutableString*)s{
	
	int x = [self.shash get:s];
	if (x != nil) {
		
		[self.buf.b appendString:[@"R" mutableCopy]];
		[self.buf.b appendString:[Std string:x]];
		return;
	}
	[self.shash set:s value:self.scount++];
	[self.buf.b appendString:[@"y" mutableCopy]];
	s = [StringTools urlEncode:s];
	[self.buf.b appendString:[Std string:s.length]];
	[self.buf.b appendString:[@":" mutableCopy]];
	[self.buf.b appendString:[Std string:s]];
}
- (BOOL) serializeRef:(id)v{
	
	{
		
		int _g1 = 0; int _g = self.cache.length;
		while (_g1 < _g) {
			
			int i = _g1++;
			if (((id)[self.cache hx_objectAtIndex:i]) == v) {
				
				[self.buf.b appendString:[@"r" mutableCopy]];
				[self.buf.b appendString:[Std string:i]];
				return YES;
			}
		}
	}
	[self.cache push:v];
	return NO;
}
- (void) serializeFields:(id)v{
	
	{
		
		int _g = 0; 
		NSMutableArray *_g1 = [Reflect fields:v];
		while (_g < _g1.length) {
			
			
			NSMutableString *f = ((NSMutableString*)[_g1 hx_objectAtIndex:_g]);
			++_g;
			[self serializeString:f];
			[self serialize:[Reflect field:v field:f]];
		}
	}
	[self.buf.b appendString:[@"g" mutableCopy]];
}
- (void) serialize:(id)v{
	
	
	ValueType *_g = [Type _typeof:v];
	
	enum s = e (_g)
	switch ( e.index ) {
		
		case 0:
		[self.buf.b appendString:[@"n" mutableCopy]];break
		case 1:
		{
			
			if (v == 0) {
				
				[self.buf.b appendString:[@"z" mutableCopy]];
				return;
			}
			[self.buf.b appendString:[@"i" mutableCopy]];
			[self.buf.b appendString:[Std string:v]];
		}break
		case 2:
		if (isnan(v)) [self.buf.b appendString:[@"k" mutableCopy]];
		else if (!isfinite(v)) [self.buf.b appendString:[Std string:( (v < @"0") ? [@"m" mutableCopy] : [@"p" mutableCopy])]];
		else {
			
			[self.buf.b appendString:[@"d" mutableCopy]];
			[self.buf.b appendString:[Std string:v]];
		};break
		case 3:
		[self.buf.b appendString:[Std string:( (v) ? [@"t" mutableCopy] : [@"f" mutableCopy])]];break
		case 6:
		
		var MATCH c : Class = e.params[0]{
			
			if (c == NSMutableString) {
				
				[self serializeString:v];
				return;
			}
			if (self.useCache && [self serializeRef:v]) return;
			switch (c){
				case NSMutableArray:{
					
					int ucount = 0;
					[self.buf.b appendString:[@"a" mutableCopy]];
					int l = ((TArray3TDynamic*)[v hx_objectAtIndex:[@"length" mutableCopy]]);
					{
						
						int _g1 = 0;
						while (_g1 < (int)l) {
							
							int i = _g1++;
							if (((TArray3TDynamic*)[v hx_objectAtIndex:i]) == nil) ucount++;
							else {
								
								if (ucount > 0) {
									
									if (ucount == 1) [self.buf.b appendString:[@"n" mutableCopy]];
									else {
										
										[self.buf.b appendString:[@"u" mutableCopy]];
										[self.buf.b appendString:[Std string:ucount]];
									}
									ucount = 0;
								}
								[self serialize:((TArray3TDynamic*)[v hx_objectAtIndex:i])];
							}
						}
					}
					if (ucount > 0) {
						
						if (ucount == 1) [self.buf.b appendString:[@"n" mutableCopy]];
						else {
							
							[self.buf.b appendString:[@"u" mutableCopy]];
							[self.buf.b appendString:[Std string:ucount]];
						}
					}
					[self.buf.b appendString:[@"h" mutableCopy]];
				}
				break;
				case List:{
					
					[self.buf.b appendString:[@"l" mutableCopy]];
					
					List *v1 = v;
					{
						id _it2 = [v1 iterator];
						while ( [_it2 hasNext] ) do {
							id i = [_it2 next];
							[self serialize:i];
						}
					}
					[self.buf.b appendString:[@"h" mutableCopy]];
				}
				break;
				case NSDate:{
					
					
					NSDate *d = v;
					[self.buf.b appendString:[@"v" mutableCopy]];
					[self.buf.b appendString:[Std string:[d toString]]];
				}
				break;
				case StringMap:{
					
					[self.buf.b appendString:[@"b" mutableCopy]];
					
					StringMap *v1 = v;
					{
						id _it3 = [v1 keys];
						while ( [_it3 hasNext] ) do {
							NSMutableString k = [_it3 next];
							{
								
								[self serializeString:k];
								[self serialize:[v1 get:k]];
							};
						}
					}
					[self.buf.b appendString:[@"h" mutableCopy]];
				}
				break;
				case IntMap:{
					
					[self.buf.b appendString:[@"q" mutableCopy]];
					
					IntMap *v1 = v;
					{
						id _it4 = [v1 keys];
						while ( [_it4 hasNext] ) do {
							int k = [_it4 next];
							{
								
								[self.buf.b appendString:[@":" mutableCopy]];
								[self.buf.b appendString:[Std string:k]];
								[self serialize:[v1 get:k]];
							};
						}
					}
					[self.buf.b appendString:[@"h" mutableCopy]];
				}
				break;
				case ObjectMap:{
					
					[self.buf.b appendString:[@"M" mutableCopy]];
					
					ObjectMap *v1 = v;
					{
						id _it5 = [v1 keys];
						while ( [_it5 hasNext] ) do {
							id k = [_it5 next];
							{
								
								[self serialize:k];
								[self serialize:[v1 get:k]];
							};
						}
					}
					[self.buf.b appendString:[@"h" mutableCopy]];
				}
				break;
				case Bytes:{
					
					
					Bytes *v1 = v;
					int i = 0;
					int max = v1.length - 2;
					
					StringBuf *charsBuf = [[StringBuf alloc] init];
					
					NSMutableString *b64 = BASE64;
					while (i < max) {
						
						int b1 = ((BytesData*)[v1.b hx_objectAtIndex:i++]);
						int b2 = ((BytesData*)[v1.b hx_objectAtIndex:i++]);
						int b3 = ((BytesData*)[v1.b hx_objectAtIndex:i++]);
						[charsBuf.b appendString:[Std string:[b64 charAt:b1 >> @"2"]]];
						[charsBuf.b appendString:[Std string:[b64 charAt: (b1 << @"4" | b2 >> @"4") & @"63"]]];
						[charsBuf.b appendString:[Std string:[b64 charAt: (b2 << @"2" | b3 >> @"6") & @"63"]]];
						[charsBuf.b appendString:[Std string:[b64 charAt:b3 & @"63"]]];
					}
					if (i == max) {
						
						int b1 = ((BytesData*)[v1.b hx_objectAtIndex:i++]);
						int b2 = ((BytesData*)[v1.b hx_objectAtIndex:i++]);
						[charsBuf.b appendString:[Std string:[b64 charAt:b1 >> @"2"]]];
						[charsBuf.b appendString:[Std string:[b64 charAt: (b1 << @"4" | b2 >> @"4") & @"63"]]];
						[charsBuf.b appendString:[Std string:[b64 charAt:b2 << @"2" & @"63"]]];
					}
					else if (i == max + 1) {
						
						int b1 = ((BytesData*)[v1.b hx_objectAtIndex:i++]);
						[charsBuf.b appendString:[Std string:[b64 charAt:b1 >> @"2"]]];
						[charsBuf.b appendString:[Std string:[b64 charAt:b1 << @"4" & @"63"]]];
					}
					
					NSMutableString *chars = charsBuf.b;
					[self.buf.b appendString:[@"s" mutableCopy]];
					[self.buf.b appendString:[Std string:chars.length]];
					[self.buf.b appendString:[@":" mutableCopy]];
					[self.buf.b appendString:[Std string:chars]];
				}
				break;
				default:{
					
					[self.cache pop];
					if ([v hxSerialize] != nil) {
						
						[self.buf.b appendString:[@"C" mutableCopy]];
						[self serializeString:[Type getClassName:c]];
						[self.cache push:v];
						[v hxSerialize:self];
						[self.buf.b appendString:[@"g" mutableCopy]];
					}
					else {
						
						[self.buf.b appendString:[@"c" mutableCopy]];
						[self serializeString:[Type getClassName:c]];
						[self.cache push:v];
						[self serializeFields:v];
					}
				}break;
			}
		}break
		case 4:
		{
			
			if (self.useCache && [self serializeRef:v]) return;
			[self.buf.b appendString:[@"o" mutableCopy]];
			[self serializeFields:v];
		}break
		case 7:
		
		var MATCH e : Enum = e.params[0]{
			
			if (self.useCache && [self serializeRef:v]) return;
			[self.cache pop];
			[self.buf.b appendString:[Std string:( (self.useEnumIndex) ? [@"j" mutableCopy] : [@"w" mutableCopy])]];
			[self serializeString:[Type getEnumName:e]];
			if (self.useEnumIndex) {
				
				[self.buf.b appendString:[@":" mutableCopy]];
				[self.buf.b appendString:[Std string:((TArray3TDynamic*)[v hx_objectAtIndex:@"1"])]];
			}
			else [self serializeString:((TArray3TDynamic*)[v hx_objectAtIndex:0])];
			[self.buf.b appendString:[@":" mutableCopy]];
			int l = ((TArray3TDynamic*)[v hx_objectAtIndex:[@"length" mutableCopy]]);
			[self.buf.b appendString:[Std string:l - @"2"]];
			{
				
				int _g1 = 2;
				while (_g1 < (int)l) {
					
					int i = _g1++;
					[self serialize:((TArray3TDynamic*)[v hx_objectAtIndex:i])];
				}
			}
			[self.cache push:v];
		}break
		case 5:
		@throw [@"Cannot serialize function" mutableCopy];break
		default:@throw [[@"Cannot serialize " mutableCopy] stringByAppendingString:[Std string:v]];break
	}
}
- (void) serializeException:(id)e{
	
	[self.buf.b appendString:[@"x" mutableCopy]];
	[self serialize:e];
}
- (id) init{
	
	self = [super init];
	self.buf = [[StringBuf alloc] init];
	self.cache = [[NSMutableArray alloc] init];
	self.useCache = USE_CACHE;
	self.useEnumIndex = USE_ENUM_INDEX;
	self.shash = [[StringMap alloc] init];
	self.scount = 0;
	return self;
}

@end
