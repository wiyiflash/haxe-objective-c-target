//
//  Test
//  Test
//
//  Source generated by Haxe Objective-C target
//

#import "../unit/Test.h"

@implementation Test

static int count;
+ (int) count {
	if (count == nil) count = 0;
	return count;
}
+ (void) setCount:(int)hx_val {
	count = hx_val;
}
static NSMutableString* reportInfos;
+ (NSMutableString*) reportInfos {
	if (reportInfos == nil) reportInfos = nil;
	return reportInfos;
}
+ (void) setReportInfos:(NSMutableString*)hx_val {
	reportInfos = hx_val;
}
static int reportCount;
+ (int) reportCount {
	if (reportCount == nil) reportCount = 0;
	return reportCount;
}
+ (void) setReportCount:(int)hx_val {
	reportCount = hx_val;
}
static int checkCount;
+ (int) checkCount {
	if (checkCount == nil) checkCount = 0;
	return checkCount;
}
+ (void) setCheckCount:(int)hx_val {
	checkCount = hx_val;
}
static NSMutableArray* asyncWaits;
+ (NSMutableArray*) asyncWaits {
	if (asyncWaits == nil) asyncWaits = [[NSMutableArray alloc] init];
	return asyncWaits;
}
+ (void) setAsyncWaits:(NSMutableArray*)hx_val {
	asyncWaits = hx_val;
}
static NSMutableArray* asyncCache;
+ (NSMutableArray*) asyncCache {
	if (asyncCache == nil) asyncCache = [[NSMutableArray alloc] init];
	return asyncCache;
}
+ (void) setAsyncCache:(NSMutableArray*)hx_val {
	asyncCache = hx_val;
}
static int AMAX;
+ (int) AMAX {
	if (AMAX == nil) AMAX = 3;
	return AMAX;
}
+ (void) setAMAX:(int)hx_val {
	AMAX = hx_val;
}
static Timer* timer;
+ (Timer*) timer {
	if (timer == nil) timer = ;
	return timer;
}
+ (void) setTimer:(Timer*)hx_val {
	timer = hx_val;
}
// Dynamic method defined with an objc method and a block property
+ (void) report:(NSMutableString*)msg pos:(id)pos{
	// Optional arguments
	if (!pos) pos = nil;
	
	if (reportInfos != nil) [msg appendString:[[[@" (" mutableCopy] stringByAppendingString:reportInfos] stringByAppendingString:[@")" mutableCopy]]];
	reportInfos = nil;
}
[Log trace:msg infos:pos];
reportCount++;
if (reportCount == 50) [Log trace:[@"Too many errors" mutableCopy] infos:@{@"fileName":@"Test.hx", @"lineNumber":@"154", @"className":@"unit.Test", @"methodName":@"report"}];
Test report = ^(NSMutableString *msg1, id pos1){
	
}
/*?*/}
/*?*/}
@synthesize hx_dyn_report;

/*?*/+ (void) checkDone{
	
	if (asyncWaits.length != 0) return;
	if (asyncCache.length == 0) {
		
		[Test report:[[[@"DONE [" mutableCopy] stringByAppendingString:count] stringByAppendingString:[@" tests]" mutableCopy]] pos:@{@"fileName":@"Test.hx", @"lineNumber":@"163", @"className":@"unit.Test", @"methodName":@"checkDone"}];
		return;
	}
	[Test resetTimer];
	while (asyncCache.length > 0 && asyncWaits.length < AMAX) [[asyncCache shift]];
}
+ (void) asyncTimeout{
	
	if (asyncWaits.length == 0) return;
	{
		
		int _g = 0; 
		NSMutableArray *_g1 = asyncWaits;
		while (_g < _g1.length) {
			
			id pos = ((NSMutableArray*)[_g1 hx_objectAtIndex:_g]);
			++_g;
			[Test report:[@"TIMEOUT" mutableCopy] pos:pos];
		}
	}
	asyncWaits = [[NSMutableArray alloc] init];
	[Test checkDone];
}
+ (void) resetTimer{
	
	if (Test.timer != nil) [Test.timer stop];
	Test.timer = [[Timer alloc] init:10000];
	Test.timer.hx_dyn_run = Test asyncTimeout;
}
+ (void) onError:(id)e msg:(NSMutableString*)msg context:(NSMutableString*)context{
	
	
	NSMutableString *msg1 = [@"???" mutableCopy];
	
	NSMutableString *stack = [CallStack toString:[CallStack exceptionStack]];
	@try {
		
		msg1 = [Std string:e];
	}
	@catch (NSException *e1) {
		
	}
	reportCount = 0;
	[Test report:[[[[@"ABORTED : " mutableCopy] stringByAppendingString:msg1] stringByAppendingString:[@" in " mutableCopy]] stringByAppendingString:context] pos:@{@"fileName":@"Test.hx", @"lineNumber":@"198", @"className":@"unit.Test", @"methodName":@"onError"}];
	reportInfos = nil;
	[Log trace:[[@"STACK :\n" mutableCopy] stringByAppendingString:stack] infos:@{@"fileName":@"Test.hx", @"lineNumber":@"200", @"className":@"unit.Test", @"methodName":@"onError"}];
}

- (void) eq:(id)v v2:(id)v2 pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	if (v != v2) [Test report:[[[Std string:v] stringByAppendingString:[@" should be " mutableCopy]] stringByAppendingString:[Std string:v2]] pos:pos];
}
- (void) feq:(float)v v2:(float)v2 pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	if (!isfinite(v) || !isfinite(v2)) [self eq:v v2:v2 pos:pos];
	else if (fabsf(v - v2) > 1e-15) [Test report:[[v stringByAppendingString:[@" should be " mutableCopy]] stringByAppendingString:v2] pos:pos];
}
- (void) t:(BOOL)v pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	[self eq:v v2:YES pos:pos];
}
- (void) f:(BOOL)v pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	[self eq:v v2:NO pos:pos];
}
- (void) _assert:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	[Test report:[@"Assert" mutableCopy] pos:pos];
}
- (void) exc:(id)f pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	@try {
		
		[f];
		[Test report:[@"No exception occured" mutableCopy] pos:pos];
	}
	@catch (NSException *e) {
		
	}
}
- (void) unspec:(id)f pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	@try {
		
		[f];
	}
	@catch (NSException *e) {
		
	}
}
- (void) allow:(id)v values:(NSMutableArray*)values pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	{
		
		int _g = 0;
		while (_g < values.length) {
			
			id v2 = ((T*)[values hx_objectAtIndex:_g]);
			++_g;
			if (v == v2) return;
		}
	}
	[Test report:[[[Std string:v] stringByAppendingString:[@" not in " mutableCopy]] stringByAppendingString:[Std string:values]] pos:pos];
}
- (void) hf:(Class*)c n:(NSMutableString*)n pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	if (![Lambda has:[Type getInstanceFields:c] elt:n]) [Test report:[[[Type getClassName:c] stringByAppendingString:[@" should have member field " mutableCopy]] stringByAppendingString:n] pos:pos];
}
- (void) nhf:(Class*)c n:(NSMutableString*)n pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	if ([Lambda has:[Type getInstanceFields:c] elt:n]) [Test report:[[[Type getClassName:c] stringByAppendingString:[@" should not have member field " mutableCopy]] stringByAppendingString:n] pos:pos];
}
- (void) hsf:(Class*)c n:(NSMutableString*)n pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	if (![Lambda has:[Type getClassFields:c] elt:n]) [Test report:[[[Type getClassName:c] stringByAppendingString:[@" should have static field " mutableCopy]] stringByAppendingString:n] pos:pos];
}
- (void) nhsf:(Class*)c n:(NSMutableString*)n pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	count++;
	if ([Lambda has:[Type getClassFields:c] elt:n]) [Test report:[[[Type getClassName:c] stringByAppendingString:[@" should not have static field " mutableCopy]] stringByAppendingString:n] pos:pos];
}
- (void) infos:(NSMutableString*)m{
	
	reportInfos = m;
}
- (void) async:(id)f args:(id)args v:(id)v pos:(id)pos{
	
	// Optional arguments
	if (!pos) pos = nil;
	
	if (asyncWaits.length >= AMAX) {
		
		[asyncCache push:((id)self.__r__ id f1 = ^(id f, id args, id v, id pos){ [self async:f args:args v:v pos:pos]; }; id f2 = f; id a1 = args; id v1 = v; id a2 = pos
		__r__ = ^(){
			
			{
			[f1:f2 args:a1 v:v1 pos:a2]
			return{
				
				};
			}
			return __r__{
				
				id* __r__}
			}(self))];
			return;
		}
		[asyncWaits push:pos];
		[f:args :^(id v2){
			
			count++;
			if (![asyncWaits remove:pos]) {
				
				[Test report:[@"Double async result" mutableCopy] pos:pos];
				return;
			}
			if (v != v2) [Test report:[[[Std string:v2] stringByAppendingString:[@" should be " mutableCopy]] stringByAppendingString:[Std string:v]] pos:pos];
			[Test checkDone];
		}];
	}
	- (void) asyncExc:(id)seterror f:(id)f args:(id)args pos:(id)pos{
		
		// Optional arguments
		if (!pos) pos = nil;
		
		if (asyncWaits.length >= AMAX) {
			
			[asyncCache push:((id)self.__r__ id f1 = ^(id seterror, id f, id args, id pos){ [self asyncExc:seterror f:f args:args pos:pos]; }; id a1 = seterror; id f2 = f; id a2 = args; id a3 = pos
			__r__ = ^(){
				
				{
				[f1:a1 f:f2 args:a2 pos:a3]
				return{
					
					};
				}
				return __r__{
					
					id* __r__}
				}(self))];
				return;
			}
			[asyncWaits push:pos];
			[seterror:^(id e){
				
				count++;
				if ([asyncWaits remove:pos]) [Test checkDone];
				else [Test report:[@"Multiple async events" mutableCopy] pos:pos];
			}];
			[f:args :^(id v){
				
				count++;
				if ([asyncWaits remove:pos]) {
					
					[Test report:[@"No exception occured" mutableCopy] pos:pos];
					[Test checkDone];
				}
				else [Test report:[@"Multiple async events" mutableCopy] pos:pos];
			}];
		}
		- (void) log:(id)msg pos:(id)pos{
			
			// Optional arguments
			if (!pos) pos = nil;
			
			[Log trace:msg infos:pos];
		}
		- (id) init{
			
			self = [super init];
			return self;
		}

@end
